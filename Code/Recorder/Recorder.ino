#include <Adafruit_GFX.h>
#include <Adafruit_SSD1351.h>
#include <Adafruit_VS1053.h>
#include <SPI.h>

#define VERSION "Development_4"
#define VS1053BUTTONCOUNT 7

// Color definitions
#define BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define WHITE   0xFFFF

// Text Boxes
#define TOP       0
#define BOTTOM    1
#define LEFT      2
#define RIGHT     3
#define CENTER    4
#define CLEAR     0
#define PRINT     1

// TFT Connection
#define TFT_DC    8
#define TFT_CS    10
#define TFT_RESET 9

// VS1053 Connection
#define VS1053_RESET  A2      // VS1053 reset pin (output)
#define VS1053_CS     A1     // VS1053 chip select pin (output)
#define VS1053_DCS    A3      // VS1053 Data/command select pin (output)
#define VS1053_CARDCS A4     // Card chip select pin
#define VS1053_DREQ   2      // VS1053 Data request, ideally an Interrupt pin, see http://arduino.cc/en/Reference/attachInterrupt

// Create VS1053 object!
Adafruit_VS1053_FilePlayer musicPlayer = Adafruit_VS1053_FilePlayer(VS1053_RESET, VS1053_CS, VS1053_DCS, VS1053_DREQ, VS1053_CARDCS);
// Create TFT object!
Adafruit_SSD1351 tft = Adafruit_SSD1351(TFT_CS, TFT_DC, TFT_RESET);

const unsigned char nyanCatLight [] PROGMEM = {
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xbf, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xbf, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xef, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 
0xf8, 0xb3, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xbf, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 
0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xde, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xfb, 0xff, 0xfd, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xfb, 0xff, 0xfd, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfb, 0xdf, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 
0x9f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x9f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xdf, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3f, 0xff, 
0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0x9f, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xd0, 0xf7, 
0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xd0, 0xf7, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xcd, 0xce, 0xff, 
0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x5e, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xce, 0x1e, 0xff, 
0xff, 0xff, 0xfe, 0xff, 0xff, 0xce, 0x1e, 0xff, 0x00, 0x00, 0x02, 0xff, 0xff, 0xcf, 0xfe, 0xff, 
0xff, 0xfe, 0x70, 0xff, 0xff, 0xbd, 0xf3, 0x3f, 0x00, 0x00, 0x3c, 0xff, 0xff, 0xb9, 0x83, 0x3f, 
0xff, 0xff, 0x82, 0xff, 0xff, 0xbf, 0xff, 0x39, 0xff, 0xff, 0x82, 0xff, 0xff, 0xbf, 0xff, 0x39, 
0x00, 0x00, 0x00, 0xff, 0xff, 0xbd, 0xaf, 0x3f, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xcc, 0x0e, 0xff, 
0x00, 0x00, 0x00, 0xff, 0xff, 0xf7, 0xfd, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf7, 0xfd, 0xff, 
0xff, 0xff, 0xfe, 0xff, 0xff, 0xf0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xdf, 0xff, 
0xff, 0xff, 0xf0, 0x3f, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xef, 0x00, 0x00, 0x00, 0x3f, 0xff, 
0xff, 0xff, 0xef, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf7, 0xfd, 0xee, 0xef, 0x77, 0xb7, 0xbf, 0xff, 
0xff, 0xff, 0xe1, 0xe0, 0x70, 0x30, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xfe, 0xff, 
0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 
0xfc, 0xbf, 0xff, 0xf9, 0x9f, 0xf7, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0x9f, 0xff, 0xef, 0xff, 
0x9f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xcf, 0xff, 0xf8, 0x93, 0xff, 0xbd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfd, 0xff, 0x9f, 0x7f, 0xef, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xef, 
0xfc, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 
};

const unsigned char nyanCatDark[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
0x07, 0x4c, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 
0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x21, 0x00, 0x00, 0x01, 0x80, 0x00, 0x04, 0x00, 0x02, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x04, 0x00, 0x02, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x20, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 
0x60, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xc0, 0x00, 
0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x60, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3c, 0x2f, 0x08, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x3c, 0x2f, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x32, 0x31, 0x00, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x31, 0xa1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x31, 0xe1, 0x00, 
0x00, 0x00, 0x01, 0x00, 0x00, 0x31, 0xe1, 0x00, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x30, 0x01, 0x00, 
0x00, 0x01, 0x8f, 0x00, 0x00, 0x42, 0x0c, 0xc0, 0xff, 0xff, 0xc3, 0x00, 0x00, 0x46, 0x7c, 0xc0, 
0x00, 0x00, 0x7d, 0x00, 0x00, 0x40, 0x00, 0xc6, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x40, 0x00, 0xc6, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x42, 0x50, 0xc0, 0x00, 0x00, 0x01, 0x00, 0x00, 0x33, 0xf1, 0x00, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x08, 0x02, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x08, 0x02, 0x00, 
0x00, 0x00, 0x01, 0x00, 0x00, 0x0f, 0xfe, 0xc0, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x20, 0x00, 
0x00, 0x00, 0x0f, 0xc0, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xc0, 0x00, 
0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x08, 0x02, 0x11, 0x10, 0x88, 0x48, 0x40, 0x00, 
0x00, 0x00, 0x1e, 0x1f, 0x8f, 0xcf, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00, 
0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
0x03, 0x40, 0x00, 0x06, 0x60, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 
0x60, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x30, 0x00, 0x07, 0x6c, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x00, 0x60, 0x80, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x10, 
0x03, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
};

const unsigned char doge_1[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9f, 0xc0, 0x1f, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xff, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xef, 0x80, 0x00, 0x00, 
0x00, 0x03, 0xff, 0xff, 0xdf, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xdf, 0x80, 0x00, 0x00, 
0x00, 0x07, 0xff, 0xff, 0xbf, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf9, 0x80, 0x00, 0x00, 
0x00, 0x0f, 0xff, 0xff, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xff, 0xff, 0xe3, 0x00, 0x00, 0x00, 
0x00, 0x10, 0xff, 0xff, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x18, 0xfe, 0x1f, 0xff, 0x00, 0x00, 0x00, 
0x00, 0x38, 0x7d, 0xcf, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7d, 0x07, 0xfc, 0x00, 0x00, 0x00, 
0x00, 0x70, 0xfa, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf2, 0x07, 0xfc, 0x00, 0x00, 0x00, 
0x00, 0xfb, 0xf2, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xf8, 0x0f, 0xfc, 0x00, 0x00, 0x00, 
0x00, 0xfc, 0x7e, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0xff, 0xfc, 0x00, 0xf8, 0x00, 
0x00, 0xfc, 0x7f, 0xff, 0xfd, 0x03, 0xff, 0x00, 0x00, 0xfc, 0x7f, 0xff, 0xfd, 0x07, 0xff, 0x80, 
0x00, 0xfc, 0x0f, 0xff, 0xff, 0x07, 0xff, 0xc0, 0x00, 0x7e, 0x3f, 0xff, 0xff, 0x0f, 0xff, 0xe0, 
0x01, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf1, 0xe0, 0x01, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf1, 0xe0, 
0x01, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xf0, 0x03, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf0, 0xf0, 
0x01, 0xff, 0xff, 0xff, 0xff, 0x43, 0xf0, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x41, 0xf0, 0x78, 
0x01, 0xff, 0xff, 0xff, 0xfc, 0xc0, 0xf0, 0xf0, 0x01, 0xff, 0xff, 0xff, 0xfd, 0xc0, 0x30, 0x70, 
0x01, 0xff, 0xff, 0xff, 0xfb, 0xe0, 0x00, 0x78, 0x00, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf0, 
0x00, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x78, 0x00, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x00, 0x60, 
0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x70, 
0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xc0, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 
0x00, 0x7f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0x00, 0x24, 0x00, 
0x00, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0xb8, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x01, 0xf8, 0x00, 
0x00, 0x1f, 0xff, 0xff, 0x80, 0x07, 0x70, 0x00, 0x00, 0xcf, 0xff, 0xff, 0x03, 0xfc, 0xf0, 0x00, 
0x01, 0xcf, 0xfd, 0xfe, 0x07, 0xf8, 0xe0, 0x00, 0x07, 0xe3, 0xff, 0xfe, 0x0f, 0xf1, 0x80, 0x00, 
0x0f, 0xe0, 0xfb, 0xfc, 0x1f, 0xe0, 0x00, 0x00, 0x3f, 0xc0, 0x07, 0xf0, 0x1f, 0x80, 0x00, 0x00, 
0x1f, 0x80, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// Status led pin:
const int ledPin = A0;      // the number of the LED pin
int ledState = HIGH; // the current state of the output pin

// Variables for button presses and handeling debounce:
const int buttonVS1053[] = {0, 1, 2, 3, 5, 6, 4, 7};    // the number of the pushbutton pin
int buttonStateVS1053_Current[8];// the current buttonReading from the input pin
int buttonStateVS1053_Previous[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH};   // the previous buttonReading from the input pin
// the following variables are long's because the time, measured in miliseconds,
// will quickly become a bigger number than can be stored in an int.
long lastDebounceTime = 0;  // the last time the output pin was toggled
#define DEBOUNCEDELAY 50    // the debounce time; increase if the output flickers

// Variables for VS1053
File recording;  // the file we will save our recording to
#define RECBUFFSIZE 64  // 64 or 128 bytes.
uint8_t recording_buffer[RECBUFFSIZE];
uint8_t isRecording = false;
uint8_t toggleRecording = false;
//int volume[] = {20, 20};
#define volume 10
// float p = 3.1415926;

// Function Prototypes
// Draw text on screen
void textBox(int boxRegion, int textAction, char *text, uint16_t textColor, uint16_t backgroundColor);
// Handle system operations
void systemControl(int change, int action);
uint16_t saveRecordedData(boolean isrecord);

void setup() {
  // set initial LED state
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, ledState);

  tft.begin();
  tft.fillScreen(BLACK);
  textBox(0, 1, VERSION, YELLOW, BLACK);
  tft.drawBitmap(32, 32, doge_1, 64, 64, RED);

  // VS1053 setup
  if (! musicPlayer.begin()) { // initialise the music player
    //textBox(0, 1, "Couldn't find VS1053, HALT!", RED, BLACK);
    while (1); // don't do anything more
  }
  //textBox(0, 1, "VS1053 found.", YELLOW);
  musicPlayer.sineTest(0x44, 500);    // Make a tone to indicate VS1053 is working

  if (!SD.begin(VS1053_CARDCS)) {
    textBox(0, 1, "SD failed, or not present, HALT!", RED, BLACK);
    while (1);  // don't do anything more
  }
  //textBox(0, 1, "SD OK.", YELLOW, BLACK);

  // Set volume for left, right channels. lower numbers == louder volume!
  // musicPlayer.setVolume(volume[0], volume[1]);
  musicPlayer.setVolume(volume, volume);
  musicPlayer.useInterrupt(VS1053_FILEPLAYER_PIN_INT);
  //if (! musicPlayer.useInterrupt(VS1053_FILEPLAYER_PIN_INT)){
    //textBox(0, 1, "DREQ pin is not an interrupt pin", YELLOW, BLACK);
  //} else {
    //textBox(0, 1, "DREQ pin is an interrupt pin", YELLOW, BLACK);
  //}
  //delay(500);

  //load plugin from SD card! We'll use mono 44.1KHz, high quality
  if (! musicPlayer.prepareRecordOgg("v44k1q05.img")) {
    textBox(0, 1, "Plugin FAILED :(", YELLOW, BLACK);
    //while (1);
  } else {
    textBox(0, 1, "Plugin loaded!", YELLOW, BLACK);

  }
  musicPlayer.sineTest(0x44, 500);

  ledState = LOW;
  digitalWrite(ledPin, ledState);
}

void loop() {
  for (int pinSelect = 0; pinSelect <= VS1053BUTTONCOUNT; pinSelect++) {
    // read the state of the switch into a local variable:
    int buttonReading = musicPlayer.GPIO_digitalRead(buttonVS1053[pinSelect]);

    // check to see if you just pressed the button
    // (i.e. the input went from LOW to HIGH),  and you've waited
    // long enough since the last press to ignore any noise:

    // If the switch changed, due to noise or pressing:
    if (buttonReading != buttonStateVS1053_Previous[pinSelect]) {
      // reset the debouncing timer
      lastDebounceTime = millis();
    }

    if ((millis() - lastDebounceTime) > DEBOUNCEDELAY) {
      // whatever the buttonReading is at, it's been there for longer
      // than the debounce delay, so take it as the actual current state:
      // if the button state has changed:
      if (buttonReading != buttonStateVS1053_Current[pinSelect]) {
        buttonStateVS1053_Current[pinSelect] = buttonReading;
        // only toggle the LED if the new button state is HIGH
        if (buttonStateVS1053_Current[pinSelect] == HIGH) {
          digitalWrite(ledPin, HIGH);
          systemControl(pinSelect, HIGH);
        } else{
		  systemControl(pinSelect, LOW);
          digitalWrite(ledPin, LOW);
          //systemControl(pinSelect, LOW);
        }
      }
    }
    // save the buttonReading.  Next time through the loop,
    // it'll be the lastButtonState:
	
	if (!isRecording && buttonStateVS1053_Current[4] == HIGH) {
	//toggleRecording = HIGH;
	
	isRecording = true;
	//delay(500);	  
    //char filename[15];
    //strcpy(filename, "RECORD53.OGG");
	textBox(BOTTOM, 1, "open file", YELLOW, BLACK);
    //recording = SD.open(filename, FILE_WRITE);
    if (! recording) {
		textBox(BOTTOM, 1, "NOT RECORDING", YELLOW, BLACK);
       while (1) {
		digitalWrite(ledPin, !ledState);
	   };
    }
	textBox(BOTTOM, 1, "startRecordOgg", YELLOW, BLACK);
    //musicPlayer.startRecordOgg(true); // use microphone (for linein, pass in 'false')
  
  }

  if (isRecording == true){
	textBox(BOTTOM, 1, "save recording", YELLOW, BLACK);
    //saveRecordedData(isRecording);
	delay(200);
	digitalWrite(ledPin, !ledState);	
  }
  
  if (isRecording && buttonStateVS1053_Current[4] == HIGH) {
	//toggleRecording = false;
    textBox(BOTTOM, 1, "end recording", YELLOW, BLACK);
	//musicPlayer.stopRecordOgg();
    isRecording = false;
	delay(200);
	textBox(BOTTOM, 1, "Flush all the data!", YELLOW, BLACK);
    // Flush all the data!
    //saveRecordedData(isRecording);
    // close it up
	delay(200);
	textBox(BOTTOM, 1, "Close the file.", YELLOW, BLACK);
    //recording.close();
    delay(1000);
  }
  
    buttonStateVS1053_Previous[pinSelect] = buttonReading;
  }
 
  
}

void systemControl(int action, int change){
    switch(action) {
      case 0:
        //textBox(BOTTOM, 1, "0", YELLOW, BLACK);
		if (change == HIGH){
		  tft.fillScreen(BLACK);
		  tft.drawBitmap(32, 32, nyanCatLight, 64, 64, RED);
        } else{
		  tft.fillScreen(BLACK);
		  tft.drawBitmap(32, 32, nyanCatDark, 64, 64, RED);
        }
        break;
      case 1:
        textBox(BOTTOM, 1, "1", YELLOW, BLACK);
        break;
      case 2:
        textBox(BOTTOM, 1, "    play - LISTEN!", YELLOW, BLACK);
        musicPlayer.startPlayingFile("RECORD53.OGG");
        break;
      case 3:
        musicPlayer.stopPlaying();
        textBox(BOTTOM, 1, "    STOP - QUIET!", YELLOW, BLACK);
        break;
      case 4:
        if (toggleRecording == LOW){
			toggleRecording = HIGH;
		} else {
			toggleRecording = LOW;
		}
        break;
      case 5:
        textBox(BOTTOM, 1, "5", YELLOW, BLACK);
        break;
      case 6:
         textBox(BOTTOM, 1, "6", YELLOW, BLACK);
        break;
      case 7:textBox(BOTTOM, 1, "7", YELLOW, BLACK);
        break;
      default:
        break;
    }
}

uint16_t saveRecordedData(boolean isrecord) {
  uint16_t written = 0;

  // read how many words are waiting for us
  uint16_t wordswaiting = musicPlayer.recordedWordsWaiting();

  // try to process 256 words (512 bytes) at a time, for best speed
  while (wordswaiting > 256) {
    ////Serial.print("Waiting: "); //Serial.println(wordswaiting);
    // for example 128 bytes x 4 loops = 512 bytes
    for (int x=0; x < 512/RECBUFFSIZE; x++) {
      // fill the buffer!
      for (uint16_t addr=0; addr < RECBUFFSIZE; addr+=2) {
        uint16_t t = musicPlayer.recordedReadWord();
        ////Serial.println(t, HEX);
        recording_buffer[addr] = t >> 8;
        recording_buffer[addr+1] = t;
      }
      if (! recording.write(recording_buffer, RECBUFFSIZE)) {
        //Serial.print("Couldn't write "); //Serial.println(RECBUFFSIZE);
        //while (1);
      }
    }
    // flush 512 bytes at a time
    recording.flush();
    written += 256;
    wordswaiting -= 256;
  }

  wordswaiting = musicPlayer.recordedWordsWaiting();
  if (!isrecord) {
    //Serial.print(wordswaiting); //Serial.println(" remaining");
    // wrapping up the recording!
    uint16_t addr = 0;
    for (int x=0; x < wordswaiting-1; x++) {
      // fill the buffer!
      uint16_t t = musicPlayer.recordedReadWord();
      recording_buffer[addr] = t >> 8;
      recording_buffer[addr+1] = t;
      if (addr > RECBUFFSIZE) {
        if (! recording.write(recording_buffer, RECBUFFSIZE)) {
          //Serial.println("Couldn't write!");
          while (1);
        }
        recording.flush();
        addr = 0;
      }
    }
    if (addr != 0) {
      if (!recording.write(recording_buffer, addr)) {
        //Serial.println("Couldn't write!");
        //while (1);
      }
      written += addr;
    }
    musicPlayer.sciRead(VS1053_SCI_AICTRL3);
    if (! (musicPlayer.sciRead(VS1053_SCI_AICTRL3) & _BV(2))) {
      recording.write(musicPlayer.recordedReadWord() & 0xFF);
      written++;
    }
    recording.flush();
  }

  return written;
}

void textBox(int boxRegion, int textAction, char *text, uint16_t textColor, uint16_t backgroundColor){
  switch (boxRegion) {
    case TOP:
      tft.fillRect(0, 0, 128, 32, backgroundColor);
      tft.setCursor(0,0);
      tft.setTextColor(textColor);
      tft.print(text);
      break;
    case BOTTOM:
      tft.fillRect(0, 96, 128, 32, backgroundColor);
      tft.setCursor(0,96);
      tft.setTextColor(textColor);
      tft.print(text);
      break;
    case LEFT:
      tft.fillRect(0, 32, 32, 96, backgroundColor);
      tft.setCursor(0,32);
      tft.setTextColor(textColor);
      tft.print(text);
      break;
    case RIGHT:
      tft.fillRect(96, 32, 128, 96, backgroundColor);
      tft.setCursor(96, 32);
      tft.setTextColor(textColor);
      tft.print(text);
      break;
    case CENTER:
      tft.fillRect(32, 32, 64, 64, backgroundColor);
      tft.setCursor(32, 32);
      tft.setTextColor(textColor);
      tft.print(text);
      break;
  }
}

